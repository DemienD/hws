# БД и Docker Compose

## Задания

- [Задание 1](#задание-1)
- [Задание 2](#задание-2)
- [Задание 3](#задание-3)
- [Задание 4](#задание-4)
- [Задание 5](#задание-5)

## Базы данных

Все данные в программах хранятся в оперативной памяти, в случае завершения программы они теряются. Для надёжного хранения данных их записывают на диск. Можно было бы просто записывать данные в файлы, но тогда вручную придётся управлять записью и чтением, фильтровать данные. А настоящие проблемы возникнут, когда нужно будет выполнять в базе данных несколько запросов одновременно.

Чтобы всего этого избежать, используют уже готовые решения — СУБД (системы управления баз данных). 


## Виды СУБД

Глобально СУБД можно разделить на две категории:

- **Реляционные** — в этих СУБД данные структурированы в виде таблиц и связей между ними (их мы и разберём в конспекте).
- **Нереляционные** (или NoSQL) — все те СУБД, которые не являются реляционными.

Среди нереляционных СУБД существует множество решений с разным подходом к хранению данных. Рассмотрим примеры.

- **Key-value** (от англ. ключ-значение) хранят данные в виде простых пар «ключ — значение», где ключ уникально идентифицирует значение. Этот подход обеспечивает высокую скорость работы и простоту использования, но ограничен в функциональности запросов. Пример: Redis.
- **Документоориентированные** СУБД хранят информацию в виде документов (обычно в формате JSON). Каждый документ может иметь свою структуру (в отличие от реляционных, где структура каждой записи определена форматом таблицы), что делает их гибкими для хранения неоднородных данных. Пример: MongoDB.
- **Колоночные** (колончатые) базы данных организуют данные по столбцам вместо традиционных строк, что оптимизирует их для аналитических запросов и работы с большими объёмами данных. Пример: Apache Cassandra, ClickHouse.

Каждый тип базы данных имеет преимущества и используется в зависимости от специфики задачи и требований к производительности, масштабируемости и сложности запросов.

Традиционным и широко используемым решением по-прежнему являются классические реляционные СУБД.

## Реляционные СУБД

Вспомним, как мы хранили данные в памяти программы до знакомства с СУБД.

Обычно мы описывали формат хранимых данных с помощью классов, выделяли отдельные поля сущности и их типы. А затем хранили всё это в списке или словаре.

Взаимодействуя с БД, первый наш шаг будет точно таким же: мы должны сообщить базе данных, какую сущность мы хотим хранить (аналог — название класса в коде) и какие поля должны быть у сущности (аналог — поле класса). Также для каждого поля необходимо сообщить БД тип данных, чтобы она могла наиболее эффективно организовать его хранение.

В терминах БД, сущности хранятся в **строках таблицах**, поля сущности хранятся в **колонках таблицы** (их ещё можно называть столбцами), каждая колонка имеет свой **тип данных**.

Для примера смоделируем сущность пользователя и представим таблицу, в которой будут храниться пользователи.

**Сущность**

User:

- login (string);
- encryptedPassword (string);
- age (integer);
- firstName (string);
- lastName (string).

**Таблица**

| login | encryptedPassword | age | firstName | lastName |
|----|----|----|----|----|
| i.ivanov | 210$nmbg235jsfae | 20 | Иван | Иванов |
| chem.genious | idgh15sdigpu1235 | 65 | Дмитрий | Менделеев |
| linus | 123li52fg | 45 | Линус | Торвальдс |

## Подключение СУБД

Используем СУБД SQLite для хранения данных. Это простая реляционная база данных, которая под капотом хранит данные в обычном файле, но при этом предоставляет такой же интерфейс взаимодействия, как и «тяжёлые» СУБД, используемые в промышленной разработке (Postgres, Oracle). Запустим базу с помощью Docker. 

Для начала создадим на компьютере директорию, где будут храниться данные. Создадим пустой файл (можно назвать его, к примеру, `db.sqlite`), после чего запустим Docker-контейнер с помощью команды:

```bash
docker run --rm -it -v ".:/workspace" -w /workspace keinos/sqlite3 sqlite3 db.sqlite
```

Эта команда запускает команду `sqlite3`, которая предоставляет консольный интерфейс для доступа к данным в базе данных, передавая её в качестве аргумента в файл с базой данных `db.sqlite`.

> При работе на Unix-машинах (Linux, macOS), а также при использовании WSL необходимо выдать права на запись в файл для всех пользователей. Для этого выполним команды:

```
chmod 666 [файл_с_базой_данных]
chmod 777 [директория_с_базой_данных]
```

Чтобы проверить работоспособность базы, введём простой запрос:

```sql
select 'Hello, World!';
```

Если всё правильно, то в консоли отобразится «Hello, World!».

### Оперируем таблицами

Взаимодействие с базой данных (операции с данными, таблицами и прочее) происходит с помощью специального языка запросов — SQL. SQL расшифровывается как structured query language.

#### Создаём таблицу

Для создания таблицы используем выражение на SQL:

```
CREATE TABLE имя_таблицы (
    столбец1 тип_данных [ОПЦИИ],
    столбец2 тип_данных [ОПЦИИ],
);
```

> Ключевые слова языка являются регистронезависимыми, то есть можно писать `CREATE TABLE` или `create table`.

Каждая база данных имеет свой набор типов данных и опций при создании таблицы. Для SQLite основные типы следующие:

- **TEXT** — для хранения строк;
- **INTEGER** — для хранения целых чисел;
- **REAL** — для хранения вещественных чисел;
- **BLOB** — для хранения произвольной информации в виде массива байтов.

Создадим таблицу для хранения пользователей:

```sql
create table users (
	login text,
	encryptedPassword text,
	age integer,
	firstName text,
	lastName text
);
```

Опция `NOT_NULL` указывает на то, что значения столбца не должны быть null (а по умолчанию в каждый столбец можно его положить). Использование будет выглядеть так:

```sql
create table users (
	login text not null,
	encryptedPassword text not null,
	age integer not null,
	firstName text not null,
	lastName text not null
);
```

#### Изменение структуры таблицы

Используется для изменения структуры существующей таблицы (например, добавление/удаление столбцов). Таблицы часто эволюционируют в ходе развития приложения, и такие операции помогают:

```
ALTER TABLE имя_таблицы ADD COLUMN имя_столбца тип_данных [ОПЦИИ];
ALTER TABLE имя_таблицы DROP COLUMN имя_столбца;
```

К примеру, добавим поле `middleName` в таблицу `users` и удалим поле `age`:

```sql
alter table users add column middleName text;
alter table users drop column age;
```

#### Удаляем таблицу

Для удаления таблицы используется операция `DROP TABLE`. Она удаляет таблицу полностью со всеми её данными:

```
DROP TABLE имя_таблицы;
```

#### Упражнение

1. Создай таблицу `books` для описания книг в библиотеке. У книги должны быть следующие поля:

- «Название» (строка, not null);
- «Автор» (строка, not null);
- «Год выпуска» (число, может быть null);
- «Издательство» (число, может быть null).

2. Добавь колонку «Жанр» (строка, может быть null).
3. Удали колонку «Издательство».

### Первичный ключ

В таблицах можно хранить данные и производить над ними CRUD-операции. Но при удалении конкретной записи (например, одного пользователя) нужно его идентифицировать среди всех остальных. В реляционных БД для этого используется первичный ключ.

**Первичный ключ (primary key) — один или несколько столбцов таблицы, которые уникально определяют каждую запись (строку) в таблице.** В таблице не может быть двух записей с одинаковым первичным ключом.

В примере у каждого пользователя первичным ключом может быть логин. При создании таблицы колонку, представляющую из себя первичный ключ, нужно обозначить опцией `PRIMARY KEY`:

```sql
create table users (
	login text primary key,
	encryptedPassword text,
	age integer,
	firstName text,
	lastName text
);
```

#### Искусственный первичный ключ

Не всегда среди описываемых объектов колонок можно выбрать первичный ключ. Например, нужно хранить в таблице отзывы о товарах на маркетплейсе с полями:

```
user_review:
- user_id (int)
- product_id (int)
- rating (int)
- comment (text)
- created_at (text)
```

При этом:

- у одного пользователя может быть несколько отзывов о разных продуктах;
- даже комбинация `user_id` и `product_id` не является уникальной, если пользователь может оставить несколько отзывов об одном продукте (например, при обновлении отзыва).

В таких случаях необходимо ввести новое поле (можно назвать его, к примеру, id) и объявить его первичным ключом. Удобно сделать его целочисленного типа INTEGER и с каждой новой записью в таблице увеличивать на 1 — для первой записи id будет равен 1, для второй — 2, для третьей — 3. Такое можно сделать средствами самой БД, объявив колонку с опцией `AUTOINCREMENT`:

```sql
CREATE TABLE reviews (
    review_id INTEGER PRIMARY KEY AUTOINCREMENT, -- Искусственный ключ
    user_id INTEGER NOT NULL,                    -- ID пользователя
    product_id INTEGER NOT NULL,                -- ID продукта
    rating INTEGER NOT NULL,                    -- Оценка (например, от 1 до 5)
    comment TEXT,                               -- Комментарий
    created_at DATETIME NOT NULL                -- Дата создания отзыва
);
```

### Задание 1

Добавь искусственный первичный ключ `id` в созданную ранее таблицу `books`.

## Операции над данными в СУБД

Разберём, как взаимодействовать с данными внутри таблиц с помощью CRUD-операций. 

### **Добавление новых данных в таблицу**

Например, есть таблица `users`, куда нужно добавить нового пользователя. Для этого используем команду `INSERT INTO`: указываем, какие столбцы заполняем и какие значения туда кладём.

```sql
INSERT INTO имя_таблицы (столбец1, столбец2, ...) VALUES (значение1, значение2, ...);
```

**Пример**

```sql
INSERT INTO users (login, encryptedPassword, age, firstName, lastName) 
VALUES ('john_doe', 'hashed_password_123', 30, 'John', 'Doe');
```

Мы добавили пользователя с логином `john_doe`, зашифрованным паролем `hashed_password_123`, возрастом `30`, именем `John` и фамилией `Doe`. Если бы был искусственный ключ `id`, то его не нужно было бы указывать явно в списках полей — он автоматически увеличится благодаря `AUTOINCREMENT`.

Если необходимо добавить сразу несколько пользователей, то можно использовать множественный `INSERT`:

```sql
INSERT INTO reviews (user_id, product_id, rating, comment, created_at) 
VALUES 
(1, 101, 5, 'Отличный продукт!', '2023-10-01 10:00:00'),
(2, 102, 4, 'Неплохо, но можно лучше.', '2023-10-01 10:05:00'),
(3, 103, 3, NULL, '2023-10-01 10:10:00'),  -- Комментарий может быть NULL
(1, 104, 2, 'Не очень...', '2023-10-01 10:15:00');
```

Обрати внимание, что мы указываем только те столбцы, которые нужно заполнить: `(user_id, product_id, rating, comment, created_at)`. Столбец `review_id` пропущен, так как он автоматически генерируется благодаря `AUTOINCREMENT`.

### **Выборка данных из таблицы**

Теперь данные можно достать с помощью команды `SELECT`. Она позволяет выбирать нужные столбцы и фильтровать записи по определённым условиям. Базовый шаблон её использования:

```
SELECT столбец1, столбец2, ... FROM имя_таблицы [WHERE условие] [ORDER BY столбец [ASC|DESC]];
```

Разберём этот шаблон пошагово на примерах.

**1.** `SELECT столбец1, столбец2, ...`

- **Что делает.** Указывает, какие столбцы нужно включить в результат.
- **Варианты использования:**
  - Если нужно выбрать конкретные столбцы, перечисли их через запятую:

    ```sql
    SELECT firstName, age FROM users;
    ```
  - Если нужны все столбцы, используй звёздочку (`*`):

    ```sql
    SELECT * FROM users;
    ```

**Пример.** Выбрать только логины и возрасты пользователей:

```sql
SELECT login, age FROM users;
```

---

**2.** `FROM имя_таблицы`

- **Что делает.** Указывает, из какой таблицы будут выбираться данные.
- **Пример:**

  ```sql
  FROM users
  ```

  Здесь мы выбираем данные из таблицы `users`.

**3.** `[WHERE условие]` (необязательно)

- **Что делает.** Добавляет фильтр для ограничения результата. Только те записи, которые соответствуют условию, попадут в выборку.
- **Синтаксис условия.** Условие может быть составлено с использованием операторов сравнения (`=`, `>`, `<`, `<>`, `LIKE`, `IN`, `BETWEEN` и так далее) и логических операторов (`AND`, `OR`, `NOT`).
- **Примеры:**
  - Выбрать всех пользователей старше 25 лет:

    ```sql
    WHERE age > 25
    ```
  - Выбрать пользователей с логинами `john_doe` и `jane_smith`:

    ```sql
    WHERE login IN ('john_doe', 'jane_smith')
    ```
  - Выбрать пользователей, чьи логины начинаются на `j`:

    ```sql
    WHERE login LIKE 'j%'
    ```

> Оператор `LIKE` в SQL используется для поиска данных на основе шаблонов (pattern matching). Он позволяет искать строки, которые соответствуют определённому формату или содержат конкретные символы. Оператор `LIKE` сопоставляет строку с шаблоном, при этом обрабатывает специальные символы.
>
> 1. `%` (процент): обозначает любое количество символов (включая ноль). К примеру, `'j%'` найдёт все строки, которые начинаются с буквы j (например, john, jane, jump).
> 2. `_` (подчёркивание): обозначает ровно один любой символ. К примеру, `'j_n'` найдёт строки, где первый символ j, третий символ n, а между ними ровно один любой символ (например, jan, jin).

**Полный пример.** Выбрать всех пользователей старше 30 лет:

```sql
SELECT login, age FROM users WHERE age > 30;
```

**4.** `[ORDER BY столбец [ASC|DESC]]` (необязательно)

- **Что делает.** Сортирует результаты выборки по указанному столбцу.
- **Опции сортировки:**
  - `ASC` (по умолчанию): сортировка по возрастанию.
  - `DESC`: сортировка по убыванию.
- **Примеры:**
  - Отсортировать пользователей по возрасту от младших к старшим:

    ```sql
    ORDER BY age ASC
    ```
  - Отсортировать пользователей по имени в обратном алфавитном порядке:

    ```sql
    ORDER BY firstName DESC
    ```

**Полный пример.** Выбрать логины и возраст пользователей, отсортированных по возрасту в порядке убывания:

```sql
SELECT login, age FROM users ORDER BY age DESC;
```

#### **Объединение всех частей**

Теперь рассмотрим полный запрос, который объединяет все части шаблона:

```sql
SELECT login, age FROM users WHERE age > 25 ORDER BY age DESC;
```

**Что делает этот запрос**

1. Выбирает столбцы `login` и `age` из таблицы `users`.
2. Фильтрует записи, оставляя только тех пользователей, чей возраст больше 25 лет.
3. Сортирует результаты по возрасту в порядке убывания.

Используя шаблон выборки, можно:

1) выбирать нужные столбцы (`SELECT`);

2) ограничивать результаты с помощью фильтров (`WHERE`);

3) сортировать данные по определённому порядку (`ORDER BY`).

Каждая часть шаблона необязательна, но их комбинация делает запросы более мощными и точными. Например:

- без `WHERE`: выберет все записи, соответствующие выбранным столбцам;
- без `ORDER BY`: результаты не будут отсортированы (порядок зависит от базы данных).

### **Обновление данных в таблице**

Одному из пользователей исполнился 31 год. Чтобы обновить его возраст, используем команду `UPDATE`:

```
UPDATE имя_таблицы SET столбец1 = значение1, столбец2 = значение2, ... [WHERE условие];
```

**Пример**

```sql
UPDATE users SET age = 31 WHERE login = 'john_doe';
```

Мы меняем возраст пользователя с логином `john_doe` на `31`. Обрати внимание на условие `WHERE` — без него обновятся **все** записи в таблице, что может привести к неприятным последствиям. Синтаксис `WHERE` аналогичен тому, который мы изучили ранее, при использовании `SELECT`.

Можно также обновлять сразу несколько полей:

```sql
UPDATE users SET age = 31, firstName = 'Johnathan Doe' WHERE login = 'john_doe';
```

Здесь мы не только изменили возраст, но и обновили имя пользователя.

### **Удаление данных из таблицы**

Пользователь решил покинуть систему. Для удаления записей используется команда `DELETE`:

```
DELETE FROM имя_таблицы [WHERE условие];
```

**Пример**

```sql
DELETE FROM users WHERE login = 'john_doe';
```

Эта команда удаляет пользователя с логином `john_doe`. Как и в случае с `UPDATE`, важно указывать условие `WHERE`, чтобы случайно не удалить лишние записи.

Если нужно очистить всю таблицу, используем `DELETE` без условий:

```sql
DELETE FROM users;
```

### **Задание 2**

- Вставь в созданную таблицу `books` следующие записи:

| Название | Автор | Год выпуска | Издательство |
|----|----|----|----|
| Война и мир | Лев Толстой | 1869 | Азбука |
| Преступление и наказание | Фёдор Достоевский | 1866 | Эксмо |
| 1984 | Джордж Оруэлл | 1949 | Actes Sud |
| Мастер и Маргарита | Михаил Булгаков | null | Vintage |
| Гарри Поттер и философский камень | Дж. К. Роулинг | 1997 | РОСМЭН |
| Сто лет одиночества | Габриэль Гарсия Маркес | 1967 | Азбука |
| Чужак | Альбер Камю | null | Эксмо |

- Удали книги, у которых год выпуска позже 1990 года.
- Составь SELECT-запрос, который выберет название и автора книг, изданных «Азбукой» или «Эксмо» и выпущенных в 19 веке.
- Составь SELECT-запрос, который достанет авторов с именем, начинающимся с буквы «Д».

## Работа с СУБД 



<details>
  <summary>Java</summary>

**Пример.** Мы создаём приложение на Spring и хотим взаимодействовать с базой данных. Конечно, можно было бы использовать сложные фреймворки вроде Hibernate (мы их обязательно рассмотрим позже), но иногда это слишком громоздко для простых задач. В таких ситуациях помогает `JdbcTemplate` — легковесный инструмент из Spring JDBC, который позволяет выполнять SQL-запросы без лишних проблем.

### **Что такое JdbcTemplate**

`JdbcTemplate` — это класс из Spring Framework, который упрощает работу с базой данных через чистые SQL-запросы. Он выполняет всю рутинную работу: управление соединениями, обработку исключений и преобразование результатов запросов в удобные для нас объекты. Нам остаётся только писать SQL и получать результаты.

### **Настройка JdbcTemplate**

Для начала работы с `JdbcTemplate` нужно подключить зависимости Spring JDBC и драйвер `Sqlite`:

```kotlin
implementation("org.xerial:sqlite-jdbc:3.42.0.0")
implementation("org.springframework.boot:spring-boot-starter-jdbc")
```

После чего можно настроить источник данных (`DataSource`):

```java
@Configuration
public class DatabaseConfig {

    @Bean
    public DataSource dataSource() {
        DriverManagerDataSource dataSource = new DriverManagerDataSource();
        dataSource.setDriverClassName("org.sqlite.JDBC"); // Драйвер SQLite
        dataSource.setUrl("jdbc:sqlite:mydatabase.db");   // Путь к файлу БД
        return dataSource;
    }

    @Bean
    public JdbcTemplate jdbcTemplate(DataSource dataSource) {
        return new JdbcTemplate(dataSource); // Создаём экземпляр JdbcTemplate
    }
```

В URL нужно указать путь к файлу с базой данных. В указанном примере это файлик `mydatabase.db`, который находится в корневой директории проекта.

### **Выполнение CRUD-операций**

#### 1. **Добавление данных (INSERT)**

Есть таблица `users` с полями `id` (автоинкрементируемое), `name` и `age`. Чтобы добавить нового пользователя, используем метод `update()`:

```java
public void createUser(String name, int age) {
    String sql = "INSERT INTO users (name, age) VALUES (?, ?)";
    jdbcTemplate.update(sql, name, age); // Вместо ? подставятся значения
}
```

Здесь мы пишем шаблонный SQL-запрос, указывая вопросы вместо реальных значений, а `JdbcTemplate` сам позаботится о безопасной передаче параметров.

> Внимание! Никогда не создавай самостоятельно запрос, склеивая в одну строку параметры. Это чревато SQL-инъекциями — уязвимостями, с помощью которых злоумышленник сможет снести всю твою базу. Всегда используй шаблонные запросы.

#### 2. **Выборка данных (SELECT)**

Найдём всех пользователей старше определённого возраста. Для этого используем метод `query()`:

```java
public List<User> findUsersOlderThan(int age) {
    String sql = "SELECT id, name, age FROM users WHERE age > ?";
    return jdbcTemplate.query(sql, new Object[]{age}, (rs, rowNum) -> {
        User user = new User();
        user.setId(rs.getInt("id"));
        user.setName(rs.getString("name"));
        user.setAge(rs.getInt("age"));
        return user; // Преобразуем каждую строку в объект User
    });
}
```

Здесь мы указываем, как преобразовать строки из результата запроса в объекты `User`, поскольку `SQL` ничего не знает о наших Java-классах и объектах — мы должны создавать их сами.

#### 3. **Обновление данных (UPDATE)**

Если пользователь решил изменить имя, снова используем метод `update()`:

```java
public void updateUser(int id, String newName) {
    String sql = "UPDATE users SET name = ? WHERE id = ?";
    jdbcTemplate.update(sql, newName, id);
}
```

Мы меняем значение в нужной записи по её уникальному идентификатору.

#### 4. **Удаление данных (DELETE)**

Если пользователя нужно удалить, также воспользуемся методом `update()`:

```java
public void deleteUser(int id) {
    String sql = "DELETE FROM users WHERE id = ?";
    jdbcTemplate.update(sql, id);
}
```

Запись с указанным `id` удалится из таблицы.

Итак, с помощью `JdbcTemplate` можно легко выполнять CRUD-операции внутри Spring-приложения. Это особенно удобно для маленьких проектов или когда нужно быстро реализовать функциональность без привлечения тяжеловесных фреймворков.
</details>


<details>
  <summary>Python</summary>

**Пример.** Мы создаём приложение на Python и хотим взаимодействовать с базой данных. Конечно, можно использовать мощные ORM вроде SQLAlchemy, но для простых задач отлично подходит стандартный модуль `sqlite3`. Он позволяет напрямую выполнять SQL-запросы без лишних накладных расходов, а также сам обрабатывает многие детали, такие как установление соединения, выполнение запросов и управление транзакциями.

### **Работа с модулем** `sqlite3` 

Модуль `sqlite3` входит в стандартную библиотеку Python и обеспечивает удобное взаимодействие с базой данных SQLite. Он позволяет:

- **устанавливать соединение** с базой данных, которая представлена в виде файла;
- **создавать и использовать курсор**, который отправляет SQL-запросы;
- **управлять транзакциями**, выполняя изменения в базе данных с возможностью их коммита или отката;
- **обрабатывать ошибки и исключения**, возникающие при работе с базой данных.

### **Настройка подключения к базе данных**

Чтобы начать работу с SQLite, нужно создать функцию, которая устанавливает соединение с файлом базы данных. Если файл не существует, он будет создан автоматически:

```python
import sqlite3

def get_connection():
    connection = sqlite3.connect("mydatabase.db")
    return connection

# Пример использования:
conn = get_connection()   # Получаем соединение с базой данных
cursor = conn.cursor()    # Создаём курсор для отправки SQL-запросов
```

- Функция `get_connection()` инкапсулирует создание соединения, что позволяет легко переиспользовать этот код в разных частях приложения.
- Метод `sqlite3.connect()` открывает (или создаёт) файл базы данных по указанному пути.

### **Выполнение CRUD-операций**

Рассмотрим, как реализовать CRUD-операции с помощью модуля `sqlite3`.

#### 1. **Добавление данных (INSERT)**

Есть таблица users с полями `id` (автоинкрементируемое), `name` и `age`. Для добавления нового пользователя используется параметризованный SQL-запрос. Это помогает избежать SQL-инъекций:

```python
def create_user(name, age):
    """
    Добавляет нового пользователя в таблицу 'users'.
    
    :param name: Имя пользователя.
    :param age: Возраст пользователя.
    """
    conn = get_connection()           # Открываем соединение с базой
    cursor = conn.cursor()            # Получаем курсор для выполнения запросов
    sql = "INSERT INTO users (name, age) VALUES (?, ?)"
    # Используем плейсхолдеры ? для безопасной подстановки значений
    cursor.execute(sql, (name, age))
    conn.commit()                     # Фиксируем изменения в базе данных
    conn.close()                      # Закрываем соединение для освобождения ресурсов

# Пример вызова функции:
create_user("Алиса", 30)
```

- Плейсхолдеры `?` позволяют безопасно передавать значения в запрос, предотвращая возможность SQL-инъекций.
- `cursor.execute()` выполняет SQL-запрос, подставляя значения из кортежа (`name`, `age`).
- `conn.commit()` сохраняет изменения в базе данных, что особенно важно для операций модификации.
- После завершения работы соединение закрывается, что освобождает системные ресурсы.

#### 2. **Выборка данных (SELECT)**

Чтобы получить список пользователей, отвечающих определённому условию (например, возраст больше заданного значения), используем метод `execute()` и затем извлекаем данные:

```python
def find_users_older_than(age):
    """
    Возвращает список пользователей, чей возраст больше заданного.
    :param age: Минимальный возраст для фильтрации пользователей.
    :return: Список словарей, где каждый словарь представляет одного пользователя.
    """
    conn = get_connection()           # Открываем соединение с базой данных
    cursor = conn.cursor()            # Создаём курсор для выполнения запросов
    sql = "SELECT id, name, age FROM users WHERE age > ?"
    # Выполняем запрос, безопасно подставляя значение параметра age
    cursor.execute(sql, (age,))
    users = cursor.fetchall()         # Извлекаем все строки результата запроса
    conn.close()                      # Закрываем соединение

    # Преобразуем каждую строку (кортеж) в словарь для удобства дальнейшей работы
    return [{"id": row[0], "name": row[1], "age": row[2]} for row in users]

# Пример вызова функции:
older_users = find_users_older_than(25)
print(older_users)
```

- `cursor.fetchall()` возвращает список всех строк, где каждая строка представлена в виде кортежа.
- Преобразование кортежей в словари делает работу с данными более наглядной и удобной, особенно если в дальнейшем требуется доступ к отдельным полям по именам.
- После выполнения запроса соединение закрывается.

#### 3. **Обновление данных (UPDATE)**

Если требуется изменить данные пользователя, например обновить его имя, используем запрос UPDATE с условием по id:

```python
def update_user(user_id, new_name):
    """
    Обновляет имя пользователя по его идентификатору.
    
    :param user_id: Идентификатор пользователя, чьё имя требуется изменить.
    :param new_name: Новое имя пользователя.
    """
    conn = get_connection()           # Открываем соединение
    cursor = conn.cursor()            # Получаем курсор
    sql = "UPDATE users SET name = ? WHERE id = ?"
    # Параметризованный запрос: безопасно подставляем новое имя и идентификатор
    cursor.execute(sql, (new_name, user_id))
    conn.commit()                     # Сохраняем изменения
    conn.close()                      # Закрываем соединение

# Пример вызова функции:
update_user(1, "Алиса")
```

- При выполнении запроса используются два плейсхолдера для нового значения и идентификатора, что помогает предотвратить ошибки и обеспечить безопасность.
- Команда `UPDATE` изменяет только ту запись, которая соответствует условию `WHERE id = ?`.

#### 4. **Удаление данных (DELETE)**

Для удаления записи из таблицы — пользователя по ID — также используется параметризованный запрос:

```python
def delete_user(user_id):
    """
    Удаляет пользователя из таблицы 'users' по его идентификатору.
    :param user_id: Идентификатор пользователя, которого нужно удалить.
    """
    conn = get_connection()           # Открываем соединение
    cursor = conn.cursor()            # Создаём курсор
    sql = "DELETE FROM users WHERE id = ?"
    # Подставляем идентификатор пользователя в запрос
    cursor.execute(sql, (user_id,))
    conn.commit()                     # Фиксируем удаление в базе данных
    conn.close()                      # Закрываем соединение

# Пример вызова функции:
delete_user(1)
```

- Запрос `DELETE` удаляет запись, удовлетворяющую условию `WHERE id = ?`.
- Параметризированный запрос гарантирует, что только указанная запись будет затронута, что важно для предотвращения случайного удаления данных.
- Как и в предыдущих операциях, после выполнения запроса необходимо вызвать `commit()` для сохранения изменений.

> Внимание! Никогда не создавай SQL-запросы путём конкатенации строк с параметрами. Это может привести к SQL-инъекциям — уязвимостям, позволяющим злоумышленникам манипулировать запросами к твоей базе данных. Всегда используй параметризированные запросы.

</details>

### Задание 3

Напиши простой сервис, предоставляющий `CRUD` для ранее описанной таблицы `books`. Используй базу SQLite и технологии, описанные в соответствующих разделах.

## Docker Compose

В промышленной разработке для веб-сервисов не используют SQLite, потому что данные не должны храниться локально. Кроме того, необходим доступ к данным одновременно нескольким выполняющим потоком программы. Далее мы будем использовать PostgreSQL. 

Для работы с PostgreSQL нужно установить СУБД, но это делать не очень удобно. Также нужно иметь возможность запустить проект одной командой, без дополнительной установки БД и других сервисов. Для этого можно использовать Docker Compose.

Разберём, как работает Docker Compose и как его можно использовать для запуска нескольких контейнеров одновременно.

### Что такое Docker Compose

Это инструмент, который позволяет определять и запускать многоконтейнерные приложения Docker. Вместо того чтобы запускать каждый контейнер отдельно с помощью команды `docker run`, можно описать все необходимые контейнеры в одном файле `docker-compose.yml` и запустить их одной командой.

Это особенно удобно, когда есть несколько взаимосвязанных сервисов, например база данных PostgreSQL и графический интерфейс управления PgAdmin.

### Пример для PostgreSQL + PgAdmin

Нужно запустить два сервиса: PostgreSQL (для хранения данных) и PgAdmin (для удобного управления базой данных). Необходимо, чтобы эти сервисы работали вместе, а также чтобы к ним можно было подключаться локально через определённые порты.

Вот пример файла `docker-compose.yml`:

```yaml
version: '3.8'

services:
  postgres:
    image: postgres:14  # Используем официальный образ PostgreSQL версии 14
    container_name: postgres_container
    restart: always
    environment:
      POSTGRES_USER: myuser       # Имя пользователя для базы данных
      POSTGRES_PASSWORD: mypassword  # Пароль пользователя
      POSTGRES_DB: mydatabase     # Название базы данных
    ports:
      - "5432:5432"  # Проброс порта для доступа к PostgreSQL локально
    volumes:
      - postgres_data:/var/lib/postgresql/data  # Храним данные PostgreSQL в volume

  pgadmin:
    image: dpage/pgadmin4  # Используем официальный образ PgAdmin
    container_name: pgadmin_container
    restart: always
    environment:
      PGADMIN_DEFAULT_EMAIL: admin@example.com  # Email для входа в PgAdmin
      PGADMIN_DEFAULT_PASSWORD: adminpassword   # Пароль для входа в PgAdmin
    ports:
      - "5050:80"  # Проброс порта для доступа к PgAdmin локально
    depends_on:
      - postgres  # PgAdmin будет запускаться только после того, как запустится PostgreSQL

volumes:
  postgres_data:  # Объявляем volume для хранения данных PostgreSQL
```


#### Разберём файл построчно

1. `version: '3.8'` — указываем версию формата `docker-compose.yml`. Это важно, так как разные версии поддерживают разные возможности.
2. `services` — описываем все сервисы. В примере два сервиса: `postgres` и `pgadmin`.
3. `image` — указывает образ Docker, который будет использован для создания контейнера.
4. `container_name` — даёт имя контейнеру, чтобы его было легче идентифицировать.
5. `restart: always` — гарантирует, что контейнер будет автоматически перезапущен в случае падения.
6. `environment` — передаём переменные окружения в контейнер. Например, для PostgreSQL мы указываем пользователя, пароль и название базы данных.
7. `ports` — пробрасываем порты контейнера на локальную машину. Для PostgreSQL пробрасываем порт `5432`, а для PgAdmin — порт `5050`.
8. `volumes` — используем volume для хранения данных PostgreSQL. Это гарантирует, что данные не потеряются, даже если контейнер будет остановлен или удалён.
9. `depends_on` — указывает, что PgAdmin должен быть запущен только после того, как запустится PostgreSQL.


### Запуск

Чтобы запустить сервисы, необходимо открыть директорию, в которой находится файл `docker-compose.yml`, после ввести в консоли команду `docker compose up -d `. Флаг `-d` сигнализирует о том, что сервисы должны быть запущены в фоновом режиме.

### Остановка

Чтобы остановить сервисы, нужно ввести команду `docker compose down`.

### Что происходит после запуска сервисов

1. Docker создаёт два контейнера: один для PostgreSQL, другой для PgAdmin.
2. Контейнер PostgreSQL начинает слушать порт `5432` на нашей локальной машине.
3. Контейнер PgAdmin становится доступным по адресу `http://localhost:5050`.

### Как подключиться к PgAdmin

1. Открой браузер и перейди по адресу `http://localhost:5050`.
2. Войди в систему с помощью email (`admin@example.com`) и пароля (`adminpassword`), которые мы указали в `docker-compose.yml`.
3. Добавь сервер PostgreSQL, указав следующие параметры:
   - **Host name/address**: `postgres` (имя сервиса из `docker-compose.yml`, указывай его в качестве имени хоста, когда обращение идёт изнутри контейнера, а не хост-машины).
   - **Port**: `5432`.
   - **Maintenance database**: `mydatabase`.
   - **Username**: `myuser`.
   - **Password**: `mypassword`.

Теперь можно управлять своей базой данных через веб-интерфейс PgAdmin.

### Как подключиться к базе из кода

<details>
  <summary>Java</summary>

Нужно подключить драйвер PostgreSQL (по аналогии с тем, как мы подключали драйвер SQLite):

```kotlin
implementation("org.postgresql:postgresql:42.5.1")
```


А настройку подключения можно указать сразу в файле `application.properties`, после чего Spring автоматически создаст бин `DataSource` для подключения к PostgreSQL.

```ini
spring.datasource.url=jdbc:postgresql://localhost:5432/mydatabase
spring.datasource.username=myuser
spring.datasource.password=mypassword
spring.datasource.driver-class-name=org.postgresql.Driver
```


Чтобы передать параметры подключения через переменные окружения, нужно использовать следующий синтаксис:

```
spring.datasource.url=${JDBC_URL:jdbc:postgresql://localhost:5432/mydatabase}
```


Если есть переменная окружения `JDBC_URL` при запуске, то конфигурация возьмётся из неё. Если переменной нет, то будет использована та, которая указана после знака `:` внутри фигурных скобок.

</details>


<details>
  <summary>Python</summary>

Для работы с PostgreSQL в Python нужно установить соответствующий драйвер. Одним из самых популярных является psycopg2. Необходимо установить пакет:

```python
pip install psycopg2-binary
```

После установки драйвера можно настроить подключение к базе данных. Конфигурацию подключения можно задать в коде или использовать переменные окружения для гибкости.

**Пример подключения через строку подключения**

```python
import psycopg2

# Строка подключения содержит информацию о пользователе, пароле, адресе сервера, порте и имени базы данных
connection_string = "postgresql://myuser:mypassword@localhost:5432/mydatabase"

# Устанавливаем соединение с базой данных
conn = psycopg2.connect(connection_string)

# Создаём курсор для выполнения SQL-запросов
cursor = conn.cursor()

# Пример запроса: получение версии PostgreSQL
cursor.execute("SELECT version();")
version = cursor.fetchone()
print("PostgreSQL version:", version)

# Закрываем курсор и соединение
cursor.close()
conn.close()
```

- `connection_string ="postgresql://myuser:mypassword@localhost:5432/mydatabase"` содержит необходимые параметры для подключения к базе данных.
- `psycopg2.connect()` устанавливает соединение с PostgreSQL с помощью указанной строки подключения.
- `cursor()` создаёт объект для выполнения SQL-запросов.
- `cursor.execute()` и `fetchone()` отправляет запрос для получения версии сервера PostgreSQL и извлекает результат, соответственно.
- `close()` закрывает курсор и соединение для освобождения ресурсов.

  

**Пример использования переменных окружения**

Ниже приведён пример подключения к PostgreSQL с использованием стандартной библиотеки и модуля `os` для извлечения переменных окружения. Если переменная не задана, используется значение по умолчанию:

```python
import os
import psycopg2

# Параметры подключения можно задать через переменные окружения.
# Если переменной нет, используются значения по умолчанию.
DATABASE_URL = os.getenv(
    "DATABASE_URL",
    "postgresql://myuser:mypassword@localhost:5432/mydatabase" # Значение по умолчанию
)

# Устанавливаем соединение с базой данных
conn = psycopg2.connect(DATABASE_URL)

# Для выполнения SQL-запросов создаём курсор:
cursor = conn.cursor()

# Пример запроса: получение версии PostgreSQL
cursor.execute("SELECT version();")
version = cursor.fetchone()
print("PostgreSQL version:", version)

# Закрываем соединение после завершения работы
cursor.close()
conn.close()
```

- `os.getenv()` извлекает строку подключения из переменной окружения `DATABASE_URL`. Если переменная не задана, используется значение по умолчанию.

</details>

### Задание 4

Замени базу данных в уже реализованном SQLite-сервисе с SQLite на Postgres.

### Задание 5

Напиши Dockerfile для твоего сервиса, собери его в имадж. 

Добавь в docker-compose.yml свой сервис (по зависимости он должен стартовать позже базы).

Настрой подключение к базе через переменные окружения.



